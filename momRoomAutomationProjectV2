/*************************************************************
  Filename - momRoomAutomationProjectV2
  Description - Room automation project which involves bathroom, fan and two LED bulb control
  version - v2 [05/02/2023]
  Updates/ Fixes - In progress
  1. RTC module DS1307 (i2c) integration and array manipulation
  2. Change new way to it connect to internet
  3. Removed debug code
 *************************************************************/

// Basic blynk configurtion
#define BLYNK_TEMPLATE_ID "TMPLExKR7Izf"
#define BLYNK_DEVICE_NAME "experimentalProj"
#define BLYNK_AUTH_TOKEN "A-CjeZj-IF4BZjeliZDUzziOFsNgw7J_"

#define BLYNK_PRINT Serial          // Comment this out to disable prints and save space

// Required header
#include <BlynkSimpleEsp8266.h>
// For RTC module
#include "RTClib.h"

// Basic configuration variables
// Tell whether LED bulb is On/ Off
boolean isBathroomLedOn = false;

// contain status of motion sensor i.e. 1 if activity detected/ 0 silent
long motionSensorStatus;

// Bathroom sensor - Active hours
int activeHourStart;
int activeHourEnd;

int NoOfTimesTryConnectingInternet = 5;
 
// Store the virtual app button value
int iAmStillInToilet = 0;

// To maintain the active alarms
struct alarm {
    int alarmId;
    int alarmType;  // 1 - Daily, 2 - Weekly, 3 - Monthly
    // Flag indicates alarm status - Enabled/disabled
    int isAlarmSet;
    // Flag indicate whether alarm triggered or not
    int isAlarmTriggered;
    int duration;
    char whomToActivate[25];

    int endTimeHour;
    int endTimeMinute;
    int endTimeSecond;
};

// Created this struct to maintain more than one alarms i.e. one for bathroom and another for bedroom bulb
// 0 - bathroom timer
// 1 - bedroom timer
struct alarm activeAlarm[2];

/* GPIO Pin configuration details */
/* ------------------------------ */
// Sensors/ Relay connection details with GPIOs pins
// D1 and D2 allotted to RTC module DS1307
#define windowBulbRelay D3
#define bathroomMotionSensor D4
#define bathroomBulbRelay D5
// Variable used for Outside bathroom - Window bulb and switch
#define windowBulbSwitch D6
#define iAmStillInToiletSwitch D7

// RTC Module
// D1/ D2 [5v required]
RTC_DS1307 rtc;
DateTime currentTime;

// virtual pins configuration
#define WindowLedVirBttn    V0
#define uptimeVirLabel    V2
#define StillInToiletVirBttn    V3  

// Window Led Relay State
bool windowLedRelayState = LOW; 

// Switch State - ON (HIGH)/ OFF (LOW)
bool windowBulbSwitchState = LOW;

// Wifi configurations
char auth[] = BLYNK_AUTH_TOKEN;
char ssid[] = "hunter22";
char pass[] = "@Serv1234@";
bool connected2Blynk = false;

BlynkTimer timer;

void checkConnection(){
  connected2Blynk = Blynk.connected();
  if(!connected2Blynk){
    Serial.println("Not connected to Blynk server"); 
    Blynk.connect(3333);  // timeout set to 10 seconds and then continue without Blynk  
  }
  else{
    Serial.println("Connected to Blynk server");     
  }
}

// For internet access
void wifiInit() {
  int noOfAttempt = 3;
  WiFi.begin(ssid, pass);  
  while (WiFi.status() != WL_CONNECTED && noOfAttempt--) {
    delay(500);
    Serial.print(".");
  }

  noOfAttempt = NoOfTimesTryConnectingInternet;

  Serial.println("");
  Serial.println("WiFi connected");  
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());  
  
  Blynk.config(auth);  // in place of Blynk.begin(auth, ssid, pass);
  Blynk.connect(3333);  // timeout set to 10 seconds and then continue without Blynk
//  while (Blynk.connect() == false && noOfAttempt--) {
//    // Wait until connected
//  }

  Serial.println("Connected to Blynk server");
  noOfAttempt = NoOfTimesTryConnectingInternet;
  timer.setInterval(60000L, checkConnection); // check if still connected every 1 minute 
}

// For RTC module setup
void rtcSetup() {
    if (! rtc.begin()) {
        Serial.println("Couldn't find RTC");
        Serial.flush();
        while (1) delay(10);
    }
    
    if (! rtc.isrunning()) {
        Serial.println("RTC is NOT running, let's set the time!");
        // When time needs to be set on a new device, or after a power loss, the
        // following line sets the RTC to the date & time this sketch was compiled
        rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
        // This line sets the RTC with an explicit date & time, for example to set
        // January 21, 2014 at 3am you would call:
        // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
    }
    Serial.println("RTC is running fine!!");
}

// duration = for how long you want to set alarm
// alarmType = 1 for hour | 2 for Minute
void setAlarm(int alarmId, int duration, int alarmType) {
    int temp = 0;
    // Bathroom Timer duration
    activeAlarm[alarmId].alarmId = alarmId;
    activeAlarm[alarmId].alarmType = alarmType;
    // tell that alarm is set
    activeAlarm[alarmId].isAlarmSet = 1;
    // Set this flag so that next time, it can be set again
    activeAlarm[alarmId].isAlarmTriggered = 0;
    activeAlarm[alarmId].duration = duration;

    // alarmType for Hour
    temp = currentTime.hour() + duration;
    activeAlarm[alarmId].endTimeHour = alarmType == 1 ? (temp > 23 ? (temp - 24) : temp) : currentTime.hour();

    // alarmType for Minute
    temp = currentTime.minute() + duration;
    activeAlarm[alarmId].endTimeMinute = alarmType == 2 ? (temp > 59 ? (temp - 60) : temp) : currentTime.minute();

    activeAlarm[alarmId].endTimeSecond = currentTime.second();
    // alarmId = 0 [bathroom bulb setup] and bulb is not glowing then only setup this
    if (alarmId == 0 && !isBathroomLedOn) {
        // Turn ON the bulb by making relay LOW
        digitalWrite(bathroomBulbRelay, LOW);
        isBathroomLedOn = true;
        Serial.println("Turn ON the bulb by making relay LOW");
    }
    
    Serial.println("Timer SET Completed");
}

void matchAlarm(int alarmId) {
    // Match condition
    for (int i=0; i < 2; i++) {
        if (alarmId == activeAlarm[i].alarmId && currentTime.hour() == activeAlarm[i].endTimeHour && currentTime.minute() >= activeAlarm[i].endTimeMinute && currentTime.second() >= activeAlarm[i].endTimeSecond && !activeAlarm[i].isAlarmTriggered) {
            Serial.println("Timer Matched - alarm triggered");
            activeAlarm[i].isAlarmSet = 0;
            activeAlarm[i].isAlarmTriggered = 1;
        }
    }
}

BLYNK_CONNECTED() {
  // Request the latest state from the server
  Blynk.syncVirtual(WindowLedVirBttn);
  Blynk.syncVirtual(StillInToiletVirBttn);
}

// When App button is pushed - switch the state
BLYNK_WRITE(WindowLedVirBttn) {
  windowLedRelayState = param.asInt();
  if(windowLedRelayState == 1){
    // Turned ON the bulb
    digitalWrite(windowBulbRelay, LOW);
    Serial.println("Turned ON the o/s bulb by app button");
  }
  else { 
    // Turned Off the bulb
    digitalWrite(windowBulbRelay, HIGH);
    Serial.println("Turned OFF the o/s bulb by app button");
  }
}

// When App button [StillInToiletVirBttn] is pushed - switch the state
BLYNK_WRITE(StillInToiletVirBttn) {
  iAmStillInToilet = param.asInt();
  Blynk.virtualWrite(StillInToiletVirBttn, iAmStillInToilet);
  Serial.println("StillInToiletVirBttn : ");
  Serial.println(iAmStillInToilet);
}

// Update the dashboard widgets
void myTimerEvent() {
  Blynk.virtualWrite(uptimeVirLabel, millis()/ 1000);
}

void manual_control() {
  if (digitalRead(windowBulbSwitch) == LOW && windowBulbSwitchState == LOW) {
    digitalWrite(windowBulbRelay, LOW);
    Blynk.virtualWrite(WindowLedVirBttn, HIGH);
    windowLedRelayState = HIGH;
    windowBulbSwitchState = HIGH;
    Serial.println("Turned On o/s LED");
  }

  if (digitalRead(windowBulbSwitch) == HIGH && windowBulbSwitchState == HIGH) {
    digitalWrite(windowBulbRelay, HIGH);
    Blynk.virtualWrite(WindowLedVirBttn, LOW);
    windowLedRelayState = LOW;
    windowBulbSwitchState = LOW;
    Serial.println("Turned Off o/s LED");
  }

  bathRoomAutomaticControl();
}

void bathRoomAutomaticControl() {
    // Bathroom Lighting hours starts from - 6 pm (18:00) till 9 am (07:00)
    activeHourStart = 18;     //  6PM
    activeHourEnd = 9;        // 9AM
    
    if (currentTime.hour() >= activeHourStart || currentTime.hour() <= activeHourEnd) {
        motionSensorStatus = digitalRead(bathroomMotionSensor);
        // activities detected
        if (motionSensorStatus == HIGH) {
          // Timer is not set
          if (activeAlarm[0].isAlarmSet == 0) {
              // int alarmId, int duration, int alarmType [
              setAlarm(0, 1, 2);
          }
        }
    }

    // Now try to match the alarm
    matchAlarm(0);

    // Check if current time reached the Off Timer and LED still ON
    if (activeAlarm[0].isAlarmTriggered == 1 && isBathroomLedOn) {
          // Check if bttn pressed for long stay
          if (digitalRead(iAmStillInToiletSwitch) == LOW) {
            // Set the new timer for 1 minute
            // int alarmId, int duration, int alarmType
            setAlarm(0, 1, 2);
            Serial.println("Set the new timer for 1 minute");
          } else {
            // Turn OFF the bulb by making relay high
            digitalWrite(bathroomBulbRelay, HIGH);
            // Resetting the flags
            isBathroomLedOn = false;
            Serial.println("Condition satisfied and turn OFF the bulb");
          }     
    }
}

void setup() {
  // Debug console
  Serial.begin(115200);
  wifiInit();

  // Initial setup
  pinMode(windowBulbRelay, OUTPUT);
  pinMode(windowBulbSwitch, INPUT_PULLUP);
  pinMode(iAmStillInToiletSwitch, INPUT_PULLUP);

  // Inside bathroom setup - make relay as output and sensor asinput
  pinMode(bathroomBulbRelay, OUTPUT);
  pinMode(bathroomMotionSensor, INPUT);

  //During Starting process - all bulb should be TURNED OFF
  // Turing relay high will turned off the bulb
  digitalWrite(windowBulbRelay, HIGH);
  digitalWrite(bathroomBulbRelay, HIGH);
  Blynk.virtualWrite(WindowLedVirBttn, windowLedRelayState);

  // Call to setup the RTC mmodule
  rtcSetup();

  // Setup a function to be called every second
  timer.setInterval(1000L, myTimerEvent);

  delay(100);
}

void loop() {
    currentTime = rtc.now();

    if(connected2Blynk){
      Blynk.run();
    }
    timer.run();

    // call all manual control i.e. switches, relay
    manual_control();

    // Standard delay
    delay(500);
}
